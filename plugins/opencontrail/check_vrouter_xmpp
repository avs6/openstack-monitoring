#!/usr/bin/env ruby

=begin

OpenContrail checks (compat. with nagios exit codes)
Copyright (C) 2014  Sebastien Badia <sebastien.badia@enovance.com>
Sources and doc <https://github.com/sbadia/contrail-nagios/>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=end

# If ruby 1.8 use rubygem
require 'rubygems' if RUBY_VERSION < '1.9.0'
# Contrail API return xml output
require 'rexml/document'
# Wrapper for net/{http,https}
require 'open-uri'
# For option managment
require 'ostruct'
require 'optparse'

# Monitoring return codes
OK        = 0
WARNING   = 1
CRITICAL  = 2
UNKNOWN   = 3
DEPENDENT = 4

# Script specific
PROG_NAME = File.basename($0)
PROG_VERSION   = '0.0.1'

req = nil
nodeok = 0

cfg = OpenStruct.new
OptionParser.new { |opts|
  opts.banner = "Usage: #{PROG_NAME} [options]"
  opts.summary_indent = '  '
  opts.version = PROG_VERSION
  opts.summary_width = 28
  opts.program_name = PROG_NAME
  opts.separator ''
  # default options
  cfg.host = 'localhost'
  cfg.port = '8085'
  cfg.ctrl = false
  cfg.mcast = false
  cfg.ip = false

  opts.on('-H','--host', "Hostname to run on (default: #{cfg.host})") do
    cfg.host = ARGV[0]
  end
  opts.on('-p','--port',"Vrouter API port (default: #{cfg.port})") do
    cfg.port = ARGV[0]
  end
  opts.on('-c','--cfg-ctrl',"Check only cfg-controller (default: #{cfg.ctrl})") do
    cfg.ctrl = true
  end
  opts.on('-m','--mcast-ctrl',"Check only mcast-controller (default: #{cfg.mcast})") do
    cfg.mcast = true
  end
  opts.on('-i','--ip-ctrl(s)',"Check this controller IPs (coma separated) (default: #{cfg.ip})") do
    cfg.ip = ARGV[0]
  end
  opts.on_tail('-h','--help','Display this help message') do
    puts opts
    exit OK
  end
}.parse!

begin
  open("http://#{cfg.host}:#{cfg.port}/Snh_AgentXmppConnectionStatusReq","User-Agent" => "#{PROG_NAME}/#{PROG_VERSION}") {|u| req = u.read }
rescue
  puts "CRITICAL: Could not connect to #{cfg.host}:#{cfg.port} (please check)"
  exit CRITICAL
end

def parse_contrail_xml(data)
  document = REXML::Document.new(data)
  xmpp = Hash.new
  node = 0
  document.elements.each('//AgentXmppData') do |x|
    elements = x.elements
    xmpp[node] = {
      :controller_ip => elements['controller_ip'].text,
      :state => elements['state'].text,
      :last_state => elements['last_state'].text,
      :last_state_at => elements['last_state_at'].text,
      :cfg_controller => elements['cfg_controller'].text,
      :mcast_controller => elements['mcast_controller'].text
    }
    node+=1
  end
  return xmpp
end # def:: parse_contrail_xml(data)

def display_peer(data,nodeid)
  return "Peer with #{data[nodeid][:controller_ip]} is #{data[nodeid][:state]} (last state #{data[nodeid][:last_state]} at #{data[nodeid][:last_state_at]})"
end # def:: display_peer(data,nodeid)

def isnt_number(n)
  false if Float(n) rescue true
end

def nagios_display(data,nodeid,ok)
  if isnt_number(nodeid)
    puts 'Please check your configuration'
    exit UNKNOWN
  end
  case data[nodeid][:state]
  when 'Established'
    puts "OK: #{display_peer(data,nodeid)}"
    ok+=1
  when 'OpenSent'
    puts "WARNING: #{display_peer(data,nodeid)}"
  else
    puts "CRITICAL: #{display_peer(data,nodeid)}"
    # exit on the first critical connection
    exit CRITICAL
  end
  return ok
end # def:: nagios_display(data,nodeid)

def nagios_exit(length,numok,cfg)
  if cfg.ctrl or cfg.mcast
    length = 1
  elsif cfg.ip
    length = cfg.ip.split(',').length
  end
  if numok == length
    exit OK
  elsif (numok < length and numok != 0)
    exit WARNING
  elsif numok == 0
    exit CRITICAL
  else
    exit UNKNOWN
  end
end # def:: nagios_exit(length,numok)

def select_node(data,key,value)
  data.each_key do |k|
    if data[k].has_key?(key)
      if data[k][key] == value
        return k
      end
    end
  end
end # def:: select_node(data,key,value)

vrouter = parse_contrail_xml(req)

if cfg.ctrl
  nagios_exit(vrouter.length,nagios_display(vrouter,select_node(vrouter,:cfg_controller,'Yes'),nodeok),cfg)
elsif cfg.mcast
  nagios_exit(vrouter.length,nagios_display(vrouter,select_node(vrouter,:mcast_controller,'Yes'),nodeok),cfg)
elsif cfg.ip
  cfg.ip.split(',').each do |ctrl_ip|
    nodeok=+nagios_display(vrouter,select_node(vrouter,:controller_ip,ctrl_ip),nodeok)
  end
  nagios_exit(vrouter.length,nodeok,cfg)
else
  vrouter.each_key do |k|
    nodeok=+nagios_display(vrouter,k,nodeok)
  end
  nagios_exit(vrouter.length,nodeok,cfg)
end

# vi:ft=ruby
